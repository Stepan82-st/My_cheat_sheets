 ////////////////////////////////////////////////////////////////////////////////
// простой объект-литерал (= ассоциативный массив) /////////////////////////////
//
// - это всего лишь коллекция именованных свойств, список пар ключ-значение
// (во многом идентичный ассоциативным массивам в других языках программирования).
// Некоторые свойства объектов могут быть функциями (объектами функций),
// которые в этом случае называются методами [Стефанов, с.22].

// создание пустого объекта-литерала ( {} ) и запись ссылки на него в переменную;
// имя объекта - переменная содержащая ссылку на литерал объекта

var a = {};

// создание объекта-литерала со свойствами и методами

var worker = {

	stat : "планктон",

	rise : function () {
		                    // this - в методе объекта при вызове - сам объект 
		switch (this.stat) {// (или контекст вызова)
		case "планктон":
			this.stat = "вожак бабуинов";
			break;
		case "вожак бабуинов":
			this.stat = "манагер";
			break;
		case "сотрудник":
			this.stat = "начальник отдела";
			break;
		case "начальник отдела":
			this.stat = "главный специалист";
			break;
		default:
			if (this.stat.indexOf("успешный") === -1)
				this.stat = "успешный " + this.stat;
			break;
		}

		return this;
	}

};

console.log(worker.stat);

worker.rise();

console.log(worker.stat);

////////////////////////////////////////////////////////////////////////////////
// в JavaScript объекты могут свободно изменять свои свойства и методы /////////

// добавление свойств и методов ////////////////////////////////////////////////

worker.nm = "Сидор";
worker.fm = "Сидоров";

worker.low = function () {

	switch (this.stat) {
	case "вожак бабуинов":
		this.stat = "планктон";
		break;
	case "манагер":
		this.stat = "вожак бабуинов";
		break;
	case "главный специалист":
		this.stat = "начальник отдела";
		break;
	case "начальник отдела":
		this.stat = "сотрудник";
		break;
	default:
		if (this.stat.indexOf(", которому еще повезет") === -1)
			this.stat = this.stat + ", которому еще повезет";
		break;
	}

	return this;

};

worker.low();
worker.low();

console.log(worker.nm + " " + worker.fm + " сейчас " + worker.stat);

// удаление свойств и методов //////////////////////////////////////////////////

delete worker.nm;

console.log(worker.nm + " " + worker.fm + " сейчас " + worker.stat);

// доступ к свойствам и методам ////////////////////////////////////////////////
//
// точечная и скобочная нотации:
//
//     объект.свойство
//     объект.метод()
//
//     объект["свойство"]
//     объект["метод"]()
//
// скобочная нотация позволяет устанавливать свойства или методы динамически
// и использовать в именах символы которые являются недопустимыми синтаксически

var k = "nm";

worker[k] = "Сидор";
worker["2-nm"] = "младший";
worker["rise"]();

console.log(worker.nm + " " + worker["fm"] + " " + worker["2-nm"] + " сейчас " + worker.stat);

delete worker["2-nm"];

worker["personal"] = function () {

	console.log(this.nm + " " + this.fm + " сейчас " + this.stat);

	return this;

};

worker.personal();

////////////////////////////////////////////////////////////////////////////////
// текучий интерфейс (fluent interface) ////////////////////////////////////////
//
// текучий интерфейс  - множественный вызов методов объекта цепочкой
// для повышения наглядности кода

worker.rise().rise().personal();

////////////////////////////////////////////////////////////////////////////////
// объект - ссылочный тип данных ///////////////////////////////////////////////
//
// ссылка - значение представляющее адрес в памяти компьютера по которому расположен объект

// ... объект равен только сам себе и не равен никакому другому объекту.
// Даже если два различных объекта обладают одним и тем же набором свойств,
// с теми же именами и значениями, они все равно будут считаться неравными.
// Два массива никогда не могут быть равными, даже если они содержат одинаковые элементы,
// следующие в одном порядке [Флэнаган, 6, с.94].

var b = {
	p1 : 234
};

var c = {
	p1 : 234
};

console.log(b === c); // false

var arr1 = [1, 2, 3, 7, 9];
var arr2 = [1, 2, 3, 7, 9];

console.log(arr1 === arr2); // false

// операция присваивания объекта (или массива) переменной фактически
// присваивает ссылку: она не создает новую копию объекта [Флэнаган, 6, с.66]

var e = b;

console.log(e === b);

e.p2 = 8;

console.log(b); //  Object { p1=234,  p2=8}

////////////////////////////////////////////////////////////////////////////////
// объект удаляется только "сборщиком мусора" и только в том случае
// если его ссылка больше нигде не содержится.
//
//     Интерпретаторы языков высокого уровня снабжаются встроенным программным обеспечением
//     под названием "сборщик мусора", задачей которого является следить за выделением
//     и использованием памяти и при необходимости автоматически освобождать
//     более не нужные участки памяти [MDN].

b.p3 = "lorem";

b = null;

console.log(b);
console.log(e);

e = null;

console.log(b);
console.log(e);

////////////////////////////////////////////////////////////////////////////////
// создание объектов с помощью функции-конструктора ////////////////////////////

// конструктором является функция вызванная с применением оператора new
//
// создание объекта:
//
//     var новый_объект = new Функция_конструктор(...);

// оператор new создает новый объект и вызывает функцию-конструктор
// функция-конструктор выполняет инициализацию создаваемого объекта через ключевое слово this
// ключевое слово this - внутри конструктора указывает на вновь создаваемый объект
// функция-конструктор не возвращает значения с использованием оператора return
//
// определение функции-конструктора:
//
//     function Функция_конструктор(...){
//
//         this.свойство1 = ...
//         this.свойство2 = ...
//         ...
//         this.свойствоN = ...
//
//         this.метод1 = function(){...}
//         this.метод2 = function(){...}
//         ...
//         this.методN = function(){...}
//
//     }

function Work(personData) {

	personData = personData || {};

	this.nm = personData.n || "кто-то";
	this.fm = personData.f || "неизвестный";
	this.stat = personData.s || "планктон";

	this.rise = function () {

		switch (this.stat) {
		case "планктон":
			this.stat = "вожак бабуинов";
			break;
		case "вожак бабуинов":
			this.stat = "манагер";
			break;
		case "сотрудник":
			this.stat = "начальник отдела";
			break;
		case "начальник отдела":
			this.stat = "главный специалист";
			break;
		default:
			if (this.stat.indexOf("успешный") === -1)
				this.stat = "успешный " + this.stat;
			break;
		}

		return this;

	};

	this.low = function () {

		switch (this.stat) {
		case "вожак бабуинов":
			this.stat = "планктон";
			break;
		case "манагер":
			this.stat = "вожак бабуинов";
			break;
		case "главный специалист":
			this.stat = "начальник отдела";
			break;
		case "начальник отдела":
			this.stat = "сотрудник";
			break;
		default:
			if (this.stat.indexOf(", которому еще повезет") === -1)
				this.stat = this.stat + ", которому еще повезет";
			break;
		}

		return this;

	};

	this.personal = function () {

		console.log(this.nm + " " + this.fm + " сейчас " + this.stat);

		return this;

	};

}

var voldemar = new Work({
		n : "Вольдемар",
		f : "Сидоров",
		s : "сотрудник"
	});

var kondrat = new Work({
		n : "Кондрат"
	});

var newWorker = new Work();

voldemar.rise().rise().rise().personal();
voldemar.low();
voldemar.personal();

kondrat.personal();

newWorker.personal();

////////////////////////////////////////////////////////////////////////////////
// методы вновь создаваемых объектов ///////////////////////////////////////////
// для уменьшения расхода памяти, выносят в прототип ///////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Прототип ////////////////////////////////////////////////////////////////////
// 
// В JavaScript каждый объект имеет свой прототип 
// (ссылка в скрытом свойстве [[prototype]]) - объект для реализации 
// прототипного наследования (делегирующего наследования на базе прототипов),
// при этом прототипом может быть любой объект. 
//
//     Для объекта-литерала 
//     
//     var a = {};
//     
//     скрытое свойство [[Prototype]] ссылается на тот же объект,
//     что и свойство prototype базового конструктора Object - Object.prototype.
//     Object - надкласс, реализующий общие возможности всех JavaScript-объектов.

// 
// Прототипом объекта, созданного с помощью оператора new, 
// является объект ссылка на который содержится в свойстве prototype функции-конструктора
// 
// При создании экземпляров объектов с помощью функции-конструктора, 
// их прототипом становится специальный объект "прототип функции-конструктора", 
// к которому созданные экземпляры получают скрытый доступ (по ссылке в скрытом 
// свойстве [[Prototype]]). Эта же ссылка содержится в свойстве 
// функции-конструктора prototype. 
//
// При попытке доступа к свойству экземпляра объекта, JavaScript проверяет,
// принадлежит ли свойство непосредственно объекту. Если нет, то интерпретатор ищет
// в прототипе данного экземпляра объекта.
// 

 function WorkP(personData) {

	personData = personData || {};

	this.nm = personData.n || "кто-то";
	this.fm = personData.f || "неизвестный";
	this.stat = personData.s || "планктон";

}

WorkP.prototype.rise = function () {// метод вынесен в прототип - свойство prototype

	switch (this.stat) {
	case "планктон":
		this.stat = "вожак бабуинов";
		break;
	case "вожак бабуинов":
		this.stat = "манагер";
		break;
	case "сотрудник":
		this.stat = "начальник отдела";
		break;
	case "начальник отдела":
		this.stat = "главный специалист";
		break;
	default:
		if (this.stat.indexOf("успешный") === -1)
			this.stat = "успешный " + this.stat;
		break;
	}

	return this;

};

WorkP.prototype.low = function () {// метод вынесен в прототип - свойство prototype

	switch (this.stat) {
	case "вожак бабуинов":
		this.stat = "планктон";
		break;
	case "манагер":
		this.stat = "вожак бабуинов";
		break;
	case "главный специалист":
		this.stat = "начальник отдела";
		break;
	case "начальник отдела":
		this.stat = "сотрудник";
		break;
	default:
		if (this.stat.indexOf(", которому еще повезет") === -1)
			this.stat = this.stat + ", которому еще повезет";
		break;
	}

	return this;

};

WorkP.prototype.personal = function () {// метод вынесен в прототип - свойство prototype

	console.log(this.nm + " " + this.fm + " сейчас " + this.stat);

	return this;

};

// Всё, что было определено в свойстве prototype в равной степени доступно и всем другим
// экземплярам (уже созданных) объектов функции-конструктора. При внесении изменений 
// в prototype все эти изменения сразу же становятся доступными 
// всем экземплярам объекта функции-конструктора [MDN].

var evgen = new WorkP({n:"Евгений", s:"сотрудник"});

evgen.personal();

WorkP.prototype.personal  = function () {// изменение метода

	console.log(this.nm + " " + this.fm + " сейчас " + this.stat + " и это не смешно");

	return this;

}; 

evgen.personal();

// Прототип (уже) созданного экземпляра объекта не может быть удален или замещен 
// другим объектом через свойство функции-конструктора prototype 
// (ссылка остается у уже созданных объектов).

WorkP.prototype = null; // замещение/удаление прототипа

var bazilio = new WorkP({n:"Базыль"});

                 // объект evgen был создан до удаления прототипа
evgen.personal();// >Евгений неизвестный сейчас главный и это не смешно

                   // объект bazilio был создан после удаления прототипа
bazilio.personal();// >TypeError: bazilio.personal is not a function

// Методы и свойства определенные через prototype могут быть переопределены в 
// созданном экземпляре объекта, при этом значения и свойства прототипа 
// (определенные через prototype) не изменяются.

var antuan = new WorkP({n:"Антуан"});

                            // у созданного объекта определяется свойство
evgen.personal = function(){// с таким же именем как в прототипе конструктора 
	
	console.log("ндряс-сь-сь-сь-сьце, Я "+this.nm+" и числюсь тут как "+ this.stat);
	
	return this;
	
};

antuan.personal();
evgen.personal();

////////////////////////////////////////////////////////////////////////////////
// this - специальная переменная ///////////////////////////////////////////////
//
// 1. в теле функции-конструктора - вновь создаваемый объект
// 2. в методе объекта при вызове - сам объект (или контекст вызова)
// 3. в теле функции (или метода) вызванной методами call или apply - значение первого
//    передаваемого аргумента методов call или apply



////////////////////////////////////////////////////////////////////////////////
// вызов функции как метода (заимствование методов) ////////////////////////////
//
// Функция в языке JavaScript – это фундаментальный тип данных [Флэнаган, 6, с.810].
//
// ... функции в языке JavaScript – это особого рода объекты. А раз
// функции являются объектами, то они имеют свойства и методы,
// как любые другие объекты [Флэнаган, 6, с.209].
//

// методы функции apply() и call() вызывают функцию как метод объекта указанного в первом аргументе
// или
// ... первый аргумент методов call() и apply() становится значением this [Флэнаган, 6, с.210].
//
// ... остальные аргументы метода call(), следующие за первым аргументом,
// определяющим контекст вызова (this), передаются вызываемой функции (как ее аргументы) [Флэнаган, 6, с.210].
//
//     функция_или_заимствуемый_метод_другого_объекта.call(заимствующий_объект, p1, p2, ... pN)
//

	var a = {
		b : 543,
		c : function (p) {
			console.log(this.b + p)
		}
	};

	var d = {
		b : 543
	};

	a.c(25); // >568
	d.c(23); // >TypeError: d.c is not a function
	a.c.call(d, 23) // >899

// Метод apply() действует подобно методу call(), за исключением того, что аргументы для функции передаются в виде массива [Флэнаган, 6, с.210].
//
//     функция_или_заимствуемый_метод_другого_объекта.apply(заимствующий_объект, [массив_аргументов])

// заимствование методов из функций-конструкторов базовых классов JavaScript
//
//     функция_конструктор.prototype.заимствуемый_метод.call(...)
//     функция_конструктор.prototype.заимствуемый_метод.apply(...)

// фрагмент верстки см. Lab9
//
//    <div id="foot_img" class="class-for-0">
//        <img alt="альтернативный текст" src="nature7.jpg">
//        <img alt="альтернативный текст" src="nature8.jpg">
//        <img alt="альтернативный текст" src="nature9.jpg">
//        <img alt="альтернативный текст" src="nature10.jpg">
//    </div>

var a = document.querySelectorAll("#foot_img img");

Array.prototype.forEach.call(a, function (x, i, arr) {

	x.alt = "oops url: " + x.src.split("/").pop();

});

// результат (фрагмент верстки см. Lab9)
//
//    <div id="foot_img" class="class-for-0">
//        <img alt="oops url: nature7.jpg" src="nature7.jpg">
//        <img alt="oops url: nature8.jpg" src="nature8.jpg">
//        <img alt="oops url: nature9.jpg" src="nature9.jpg">
//        <img alt="oops url: nature10.jpg" src="nature10.jpg">
//    </div>


var d = Array.prototype.concat.apply([], a);

var foot = document.querySelectorAll("#foot_img")[0];

d.reverse();

foot.innerHTML = "";

d.forEach(function (x, i, arr) {

	foot.appendChild(x);

});

// результат (фрагмент верстки см. Lab9)
//
//    <div id="foot_img" class="class-for-0">
//        <img alt="oops url: nature10.jpg" src="nature10.jpg">
//        <img alt="oops url: nature9.jpg" src="nature9.jpg">
//        <img alt="oops url: nature8.jpg" src="nature8.jpg">
//        <img alt="oops url: nature7.jpg" src="nature7.jpg">
//    </div>

////////////////////////////////////////////////////////////////////////////////
// копирование объектов ////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// цикл for-in /////////////////////////////////////////////////////////////////
// 
// цикл for-in проходит по всем свойствам объекта (итерация для каждого свойства), 
// в произвольном порядке
//     
//     переменная - содержит свойство объекта для каждой итерации
//     объект - объект, по чьим свойствам совершаются итерации
//     
//     for( переменная in объект ){
//     
//         /* код тела цикла */
//             
//                   ...
//             ... переменная ...
//                   ...
//             ... объект ...
//                   ...
//     
//     }
	
for (var i in worker) {

	console.log(i + " = " + worker[i]);

}

// поверхностное копирование [Стефанов, с.169-171]
function extendShallow(parental, childrenS) {
	var i;
	childrenS = childrenS || {};
	for (i in parental) {
		if (parental.hasOwnProperty(i)) { // свойство i не унаследовано?
			childrenS[i] = parental[i];
		}
	}
	return childrenS;
}

var f = {};

extend(b, f);

console.log(f); //   Object { p1=234,  p2=8}

console.log(f === b); // false

var g = extend(b);

console.log(g); //   Object { p1=234,  p2=8}

console.log(f === g); // false

// глубокое копирование [Стефанов, с.169-171]
function extendDeep(parental, childrenS) {
	var i,
	toStr = Object.prototype.toString,
	astr = "[object Array]";
	childrenS = childrenS || {};
	for (i in parental) {
		if (parental.hasOwnProperty(i)) {
			if (typeof parental[i] === "object") {
				childrenS[i] = (toStr.call(parental[i]) === astr) ? [] : {};
				extendDeep(parental[i], childrenS[i]);
			} else {
				childrenS[i] = parental[i];
			}
		}
	}
	return childrenS;
}
